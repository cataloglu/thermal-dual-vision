{
  "feature": "MQTT Integration with Home Assistant Auto-Discovery",
  "workflow_type": "feature",
  "workflow_rationale": "New module development for MQTT integration. Follows feature workflow: Core implementation → Discovery → Publishing → Testing",
  "phases": [
    {
      "id": "phase-1-core",
      "name": "MQTT Client Core",
      "type": "implementation",
      "description": "Implement basic MQTT client with connection management, callbacks, and reconnect logic",
      "depends_on": [],
      "parallel_safe": true,
      "subtasks": [
        {
          "id": "subtask-1-1",
          "description": "Create MQTTClient class with initialization and connection lifecycle",
          "service": "backend",
          "files_to_modify": [],
          "files_to_create": [
            "src/mqtt_client.py"
          ],
          "patterns_from": [
            "src/utils.py",
            "src/logger.py",
            "src/config.py"
          ],
          "verification": {
            "type": "command",
            "command": "python -c \"from src.mqtt_client import MQTTClient; from src.config import MQTTConfig; print('OK')\"",
            "expected": "OK"
          },
          "status": "pending",
          "notes": "Use asyncio-mqtt for async MQTT operations. Follow async patterns from utils.py (RateLimiter, retry_async). Use get_logger('mqtt') for logging."
        },
        {
          "id": "subtask-1-2",
          "description": "Implement connect() and disconnect() methods with connection state tracking",
          "service": "backend",
          "files_to_modify": [
            "src/mqtt_client.py"
          ],
          "files_to_create": [],
          "patterns_from": [
            "src/utils.py"
          ],
          "verification": {
            "type": "manual",
            "instructions": "Verify connect() and disconnect() methods are async and handle connection state properly. Code review to ensure proper error handling."
          },
          "status": "pending",
          "notes": "Use retry_async decorator for resilient connection. Track connection state internally."
        },
        {
          "id": "subtask-1-3",
          "description": "Implement callback system (on_connect, on_disconnect) and reconnect logic",
          "service": "backend",
          "files_to_modify": [
            "src/mqtt_client.py"
          ],
          "files_to_create": [],
          "patterns_from": [
            "src/utils.py"
          ],
          "verification": {
            "type": "manual",
            "instructions": "Verify callback registration works and reconnect logic triggers on disconnect"
          },
          "status": "pending",
          "notes": "Support multiple callbacks. Implement automatic reconnection with exponential backoff."
        }
      ]
    },
    {
      "id": "phase-2-discovery",
      "name": "Home Assistant Auto-Discovery",
      "type": "implementation",
      "description": "Implement HA MQTT auto-discovery protocol for automatic entity creation",
      "depends_on": [
        "phase-1-core"
      ],
      "parallel_safe": true,
      "subtasks": [
        {
          "id": "subtask-2-1",
          "description": "Create discovery payload builders for binary_sensor (motion)",
          "service": "backend",
          "files_to_modify": [
            "src/mqtt_client.py"
          ],
          "files_to_create": [],
          "patterns_from": [],
          "verification": {
            "type": "command",
            "command": "python -c \"from src.mqtt_client import MQTTClient; c = MQTTClient.__new__(MQTTClient); import json; p = c._build_binary_sensor_discovery(); assert 'device_class' in p and p['device_class'] == 'motion'; print('OK')\"",
            "expected": "OK"
          },
          "status": "pending",
          "notes": "Follow HA MQTT discovery format: {name, unique_id, state_topic, device_class, device}. Use spec.md discovery payload as reference."
        },
        {
          "id": "subtask-2-2",
          "description": "Create discovery payload builders for sensors (threat_level, confidence, last_analysis)",
          "service": "backend",
          "files_to_modify": [
            "src/mqtt_client.py"
          ],
          "files_to_create": [],
          "patterns_from": [],
          "verification": {
            "type": "command",
            "command": "python -c \"from src.mqtt_client import MQTTClient; c = MQTTClient.__new__(MQTTClient); payloads = [c._build_threat_sensor_discovery(), c._build_confidence_sensor_discovery(), c._build_analysis_sensor_discovery()]; assert all('state_topic' in p for p in payloads); print('OK')\"",
            "expected": "OK"
          },
          "status": "pending",
          "notes": "Create separate methods for each sensor type. Include proper units and icons where applicable."
        },
        {
          "id": "subtask-2-3",
          "description": "Implement publish_discovery() method to send all discovery configs",
          "service": "backend",
          "files_to_modify": [
            "src/mqtt_client.py"
          ],
          "files_to_create": [],
          "patterns_from": [],
          "verification": {
            "type": "manual",
            "instructions": "Verify publish_discovery() sends discovery messages to correct topics with retain=True flag"
          },
          "status": "pending",
          "notes": "Topics: homeassistant/{component}/{device_id}/{entity}/config. Use QoS from config. Set retain=True for discovery messages."
        }
      ]
    },
    {
      "id": "phase-3-publishing",
      "name": "State Publishing",
      "type": "implementation",
      "description": "Implement state publishing for motion events and analysis results",
      "depends_on": [
        "phase-2-discovery"
      ],
      "parallel_safe": true,
      "subtasks": [
        {
          "id": "subtask-3-1",
          "description": "Implement publish_motion() to publish motion state and analysis",
          "service": "backend",
          "files_to_modify": [
            "src/mqtt_client.py"
          ],
          "files_to_create": [],
          "patterns_from": [],
          "verification": {
            "type": "manual",
            "instructions": "Verify publish_motion() publishes to all relevant topics (motion state, threat_level, confidence, last_analysis)"
          },
          "status": "pending",
          "notes": "Accept detected:bool and optional analysis:AnalysisResult. Publish to multiple topics: motion/state (ON/OFF), threat_level/state, confidence/state, last_analysis/state. Note: AnalysisResult will come from task 05-llm-vision dependency."
        },
        {
          "id": "subtask-3-2",
          "description": "Implement publish_state() for generic state publishing",
          "service": "backend",
          "files_to_modify": [
            "src/mqtt_client.py"
          ],
          "files_to_create": [],
          "patterns_from": [],
          "verification": {
            "type": "manual",
            "instructions": "Verify publish_state() can publish arbitrary JSON to topic_prefix/topic"
          },
          "status": "pending",
          "notes": "Generic method for publishing any state dict. Use for custom topics beyond standard entities."
        },
        {
          "id": "subtask-3-3",
          "description": "Implement Last Will Testament (LWT) for availability tracking",
          "service": "backend",
          "files_to_modify": [
            "src/mqtt_client.py"
          ],
          "files_to_create": [],
          "patterns_from": [],
          "verification": {
            "type": "manual",
            "instructions": "Verify LWT is set during connect with topic: smart_motion/availability, payload: offline"
          },
          "status": "pending",
          "notes": "Set LWT during connection. Publish 'online' after successful connect. LWT will automatically publish 'offline' on disconnect."
        }
      ]
    },
    {
      "id": "phase-4-verification",
      "name": "Testing and Verification",
      "type": "implementation",
      "description": "Create comprehensive tests for MQTT client functionality",
      "depends_on": [
        "phase-3-publishing"
      ],
      "parallel_safe": true,
      "subtasks": [
        {
          "id": "subtask-4-1",
          "description": "Create unit tests with mock MQTT broker",
          "service": "backend",
          "files_to_modify": [],
          "files_to_create": [
            "tests/test_mqtt_client.py"
          ],
          "patterns_from": [
            "tests/__init__.py"
          ],
          "verification": {
            "type": "command",
            "command": "pytest tests/test_mqtt_client.py -v",
            "expected": "All tests pass"
          },
          "status": "pending",
          "notes": "Use pytest with asyncio support. Mock asyncio_mqtt.Client. Test: connection, discovery payloads, state publishing, callbacks, reconnect logic."
        },
        {
          "id": "subtask-4-2",
          "description": "Add integration test documentation for real broker testing",
          "service": "backend",
          "files_to_modify": [],
          "files_to_create": [
            "tests/integration/README.md"
          ],
          "patterns_from": [],
          "verification": {
            "type": "manual",
            "instructions": "Verify README.md contains instructions for testing with real Mosquitto broker"
          },
          "status": "pending",
          "notes": "Document how to test with real MQTT broker (docker run mosquitto, connect to it, verify messages). Not automated due to external dependency."
        }
      ]
    }
  ],
  "summary": {
    "total_phases": 4,
    "total_subtasks": 11,
    "services_involved": [
      "backend"
    ],
    "parallelism": {
      "max_parallel_phases": 1,
      "parallel_groups": [],
      "recommended_workers": 1,
      "speedup_estimate": "Sequential execution required due to dependencies",
      "reasoning": "Each phase depends on the previous phase. Phase 2 needs core client (Phase 1). Phase 3 needs discovery setup (Phase 2). Phase 4 needs all features implemented (Phase 3)."
    },
    "startup_command": "python src/main.py (when main.py exists)"
  },
  "verification_strategy": {
    "risk_level": "medium",
    "skip_validation": false,
    "test_creation_phase": "post_implementation",
    "test_types_required": [
      "unit"
    ],
    "security_scanning_required": false,
    "staging_deployment_required": false,
    "acceptance_criteria": [
      "MQTTClient class implements all required methods from spec",
      "Discovery payloads follow HA MQTT discovery protocol",
      "State publishing works for all entity types",
      "Reconnect logic handles disconnections gracefully",
      "LWT (Last Will Testament) is configured correctly",
      "Unit tests pass with mocked broker",
      "Code follows existing async patterns (retry_async, RateLimiter)",
      "Logging uses get_logger pattern"
    ],
    "verification_steps": [
      {
        "name": "Import Verification",
        "command": "python -c \"from src.mqtt_client import MQTTClient; print('OK')\"",
        "expected_outcome": "OK",
        "type": "test",
        "required": true,
        "blocking": true
      },
      {
        "name": "Unit Tests",
        "command": "pytest tests/test_mqtt_client.py -v",
        "expected_outcome": "All tests pass",
        "type": "test",
        "required": true,
        "blocking": true
      },
      {
        "name": "Code Pattern Compliance",
        "command": "grep -q 'get_logger' src/mqtt_client.py && grep -q 'async def' src/mqtt_client.py && echo 'OK'",
        "expected_outcome": "OK",
        "type": "test",
        "required": true,
        "blocking": false
      }
    ],
    "reasoning": "Medium risk: New integration with external system (MQTT broker) but well-defined protocol. Unit tests required to verify logic. Integration tests documented but not automated due to external dependencies. No security scanning needed as this handles published data only."
  },
  "qa_acceptance": {
    "unit_tests": {
      "required": true,
      "commands": [
        "pytest tests/test_mqtt_client.py -v"
      ],
      "minimum_coverage": null
    },
    "integration_tests": {
      "required": false,
      "commands": [],
      "services_to_test": [],
      "notes": "Integration tests require external MQTT broker. Documented in tests/integration/README.md for manual verification."
    },
    "e2e_tests": {
      "required": false,
      "commands": [],
      "flows": []
    },
    "browser_verification": {
      "required": false,
      "pages": []
    },
    "database_verification": {
      "required": false,
      "checks": []
    },
    "mqtt_verification": {
      "required": true,
      "checks": [
        "MQTTClient can connect to broker",
        "Discovery messages published to correct topics with retain=True",
        "State messages published with correct QoS",
        "LWT configured and publishes availability",
        "Reconnect logic works on disconnect"
      ],
      "manual_testing": {
        "setup": "docker run -d -p 1883:1883 eclipse-mosquitto:2",
        "verify_discovery": "mosquitto_sub -h localhost -t 'homeassistant/#' -v",
        "verify_state": "mosquitto_sub -h localhost -t 'smart_motion/#' -v",
        "trigger_event": "Call publish_motion(True) from test script"
      }
    }
  },
  "qa_signoff": null,
  "status": "in_progress",
  "planStatus": "in_progress",
  "updated_at": "2026-01-16T06:36:47.927Z"
}