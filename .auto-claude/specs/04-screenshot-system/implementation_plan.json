{
  "feature": "Screenshot System with Ring Buffer",
  "workflow_type": "feature",
  "workflow_rationale": "Building a new module that will be used by motion detection. Single service implementation with clear phases: data structures -> buffer operations -> capture logic -> storage management.",
  "phases": [
    {
      "id": "phase-1-data-structures",
      "name": "Data Structures",
      "type": "implementation",
      "description": "Define the core data structures for screenshot management including ScreenshotSet dataclass and initialize the ring buffer",
      "depends_on": [],
      "parallel_safe": true,
      "subtasks": [
        {
          "id": "subtask-1-1",
          "description": "Create ScreenshotSet dataclass with before/current/after frames",
          "service": "backend",
          "files_to_modify": [],
          "files_to_create": [
            "src/screenshot_manager.py"
          ],
          "patterns_from": [
            "src/config.py"
          ],
          "verification": {
            "type": "command",
            "command": "python -c \"from src.screenshot_manager import ScreenshotSet; print('OK')\"",
            "expected": "OK"
          },
          "status": "completed",
          "notes": "Follow dataclass pattern from config.py. Include bytes and base64 fields for both JPEG and base64 encoded versions."
        },
        {
          "id": "subtask-1-2",
          "description": "Create ScreenshotManager class with ring buffer initialization",
          "service": "backend",
          "files_to_modify": [
            "src/screenshot_manager.py"
          ],
          "files_to_create": [],
          "patterns_from": [
            "src/utils.py",
            "src/logger.py"
          ],
          "verification": {
            "type": "command",
            "command": "python -c \"from src.screenshot_manager import ScreenshotManager; from src.config import ScreenshotConfig; mgr = ScreenshotManager(ScreenshotConfig()); print('Buffer size:', mgr.get_buffer_size())\"",
            "expected": "Buffer size: 0"
          },
          "status": "completed",
          "notes": "Successfully created ScreenshotManager class with ring buffer initialization using collections.deque. The buffer is configured with maxlen=buffer_seconds*fps (50 frames for 10 seconds at 5fps). Implemented get_buffer_size() method that returns current buffer length. Added proper logging using get_logger() pattern from logger.py. Verification passed with buffer size: 0 for empty buffer.",
          "updated_at": "2026-01-16T06:39:43.289715+00:00"
        }
      ]
    },
    {
      "id": "phase-2-buffer-operations",
      "name": "Buffer Operations",
      "type": "implementation",
      "description": "Implement frame buffering with timestamps and retrieval logic",
      "depends_on": [
        "phase-1-data-structures"
      ],
      "parallel_safe": true,
      "subtasks": [
        {
          "id": "subtask-2-1",
          "description": "Implement add_frame() method to store frames with timestamps",
          "service": "backend",
          "files_to_modify": [
            "src/screenshot_manager.py"
          ],
          "files_to_create": [],
          "patterns_from": [
            "src/utils.py"
          ],
          "verification": {
            "type": "command",
            "command": "python -c \"from src.screenshot_manager import ScreenshotManager; from src.config import ScreenshotConfig; import numpy as np; from datetime import datetime; mgr = ScreenshotManager(ScreenshotConfig()); mgr.add_frame(np.zeros((100,100,3), dtype=np.uint8), datetime.now()); print('Buffer size:', mgr.get_buffer_size())\"",
            "expected": "Buffer size: 1"
          },
          "status": "completed",
          "notes": "Successfully implemented add_frame() method that stores (frame, timestamp) tuples in the ring buffer using deque.append(). The deque with maxlen automatically handles the ring buffer behavior (discards oldest when full). Method follows the patterns from utils.py with proper docstring documentation. Deque append operations are thread-safe as noted in the implementation. Committed the changes with proper git message.",
          "updated_at": "2026-01-16T06:41:33.959098+00:00"
        },
        {
          "id": "subtask-2-2",
          "description": "Implement _get_frame_before() helper to find frame N seconds before timestamp",
          "service": "backend",
          "files_to_modify": [
            "src/screenshot_manager.py"
          ],
          "files_to_create": [],
          "patterns_from": [],
          "verification": {
            "type": "command",
            "command": "python -c \"from src.screenshot_manager import ScreenshotManager; from src.config import ScreenshotConfig; import numpy as np; from datetime import datetime, timedelta; mgr = ScreenshotManager(ScreenshotConfig(before_seconds=2)); now = datetime.now(); mgr.add_frame(np.zeros((100,100,3), dtype=np.uint8), now - timedelta(seconds=3)); mgr.add_frame(np.ones((100,100,3), dtype=np.uint8), now); frame = mgr._get_frame_before(now, 2); print('Found frame:', frame is not None)\"",
            "expected": "Found frame: True"
          },
          "status": "completed",
          "notes": "Implemented _get_frame_before() helper method that searches ring buffer for frame closest to N seconds before given timestamp. Returns most recent frame at or before target time, or None if no suitable frame found.",
          "updated_at": "2026-01-16T06:43:00.082705+00:00"
        }
      ]
    },
    {
      "id": "phase-3-capture-sequence",
      "name": "Capture Sequence",
      "type": "implementation",
      "description": "Implement async capture_sequence() to get before/current/after screenshots with encoding",
      "depends_on": [
        "phase-2-buffer-operations"
      ],
      "parallel_safe": true,
      "subtasks": [
        {
          "id": "subtask-3-1",
          "description": "Implement async capture_sequence() method",
          "service": "backend",
          "files_to_modify": [
            "src/screenshot_manager.py"
          ],
          "files_to_create": [],
          "patterns_from": [
            "src/utils.py"
          ],
          "verification": {
            "type": "command",
            "command": "python -c \"import asyncio; from src.screenshot_manager import ScreenshotManager; from src.config import ScreenshotConfig; import numpy as np; from datetime import datetime, timedelta; async def test(): mgr = ScreenshotManager(ScreenshotConfig(before_seconds=1, after_seconds=1)); now = datetime.now(); for i in range(5): mgr.add_frame(np.zeros((100,100,3), dtype=np.uint8) + i*50, now + timedelta(seconds=i-2)); screenshot_set = await mgr.capture_sequence(np.ones((100,100,3), dtype=np.uint8) * 128); print('Has before:', screenshot_set.before is not None); print('Has current:', screenshot_set.current is not None); print('Has after:', screenshot_set.after is not None); asyncio.run(test())\"",
            "expected": "Has before: True\nHas current: True\nHas after: True"
          },
          "status": "completed",
          "notes": "Successfully implemented async capture_sequence() method. The method:\n- Retrieves a frame from before the event using _get_frame_before()\n- Uses the provided current_frame argument\n- Waits for after_seconds using asyncio.sleep() to allow buffer to fill\n- Retrieves a frame from after the event using _get_frame_after() (new helper method)\n- Encodes all three frames to both JPEG bytes and base64 strings using utils functions\n- Returns a complete ScreenshotSet with all required fields\n- Includes proper error handling with ValueError when frames are not available\n- Logs capture details including byte sizes\nImplementation follows patterns from utils.py for async operations and encoding. Note: This implementation also includes the JPEG/Base64 encoding functionality from subtask-3-2 since they are naturally part of the same method.",
          "updated_at": "2026-01-16T06:45:09.178131+00:00"
        },
        {
          "id": "subtask-3-2",
          "description": "Add JPEG encoding and Base64 conversion to capture_sequence()",
          "service": "backend",
          "files_to_modify": [
            "src/screenshot_manager.py"
          ],
          "files_to_create": [],
          "patterns_from": [
            "src/utils.py"
          ],
          "verification": {
            "type": "command",
            "command": "python -c \"import asyncio; from src.screenshot_manager import ScreenshotManager; from src.config import ScreenshotConfig; import numpy as np; from datetime import datetime, timedelta; async def test(): mgr = ScreenshotManager(ScreenshotConfig(before_seconds=1, after_seconds=1, quality=85)); now = datetime.now(); for i in range(5): mgr.add_frame(np.zeros((100,100,3), dtype=np.uint8) + i*50, now + timedelta(seconds=i-2)); screenshot_set = await mgr.capture_sequence(np.ones((100,100,3), dtype=np.uint8) * 128); print('JPEG bytes:', len(screenshot_set.current) > 0); print('Base64 string:', len(screenshot_set.current_base64) > 0); print('Valid base64:', screenshot_set.current_base64.isalnum() or '+' in screenshot_set.current_base64 or '/' in screenshot_set.current_base64); asyncio.run(test())\"",
            "expected": "JPEG bytes: True\nBase64 string: True\nValid base64: True"
          },
          "status": "pending",
          "notes": "Use encode_frame_to_bytes() and encode_frame_to_base64() from utils.py. Apply quality setting from config. Populate all fields in ScreenshotSet (bytes + base64 for all 3 frames)."
        }
      ]
    },
    {
      "id": "phase-4-storage-management",
      "name": "Storage Management",
      "type": "implementation",
      "description": "Implement cleanup and optional disk storage features",
      "depends_on": [
        "phase-3-capture-sequence"
      ],
      "parallel_safe": true,
      "subtasks": [
        {
          "id": "subtask-4-1",
          "description": "Implement cleanup_old() to remove old screenshot sets",
          "service": "backend",
          "files_to_modify": [
            "src/screenshot_manager.py"
          ],
          "files_to_create": [],
          "patterns_from": [],
          "verification": {
            "type": "command",
            "command": "python -c \"from src.screenshot_manager import ScreenshotManager; from src.config import ScreenshotConfig; print('Cleanup method exists:', hasattr(ScreenshotManager(ScreenshotConfig()), 'cleanup_old'))\"",
            "expected": "Cleanup method exists: True"
          },
          "status": "pending",
          "notes": "Store screenshot sets in a list. cleanup_old(max_count) should keep only the most recent max_count screenshots. Use max_stored from config as default."
        },
        {
          "id": "subtask-4-2",
          "description": "Add memory usage tracking and buffer statistics",
          "service": "backend",
          "files_to_modify": [
            "src/screenshot_manager.py"
          ],
          "files_to_create": [],
          "patterns_from": [
            "src/logger.py"
          ],
          "verification": {
            "type": "command",
            "command": "python -c \"from src.screenshot_manager import ScreenshotManager; from src.config import ScreenshotConfig; mgr = ScreenshotManager(ScreenshotConfig()); print('Buffer size:', mgr.get_buffer_size()); print('Methods exist:', hasattr(mgr, 'get_buffer_size'))\"",
            "expected": "Buffer size: 0\nMethods exist: True"
          },
          "status": "pending",
          "notes": "Add methods to get buffer statistics. Log buffer size periodically to detect memory issues. Ensure get_buffer_size() returns current deque length."
        }
      ]
    },
    {
      "id": "phase-5-integration-tests",
      "name": "Integration Testing",
      "type": "integration",
      "description": "Create comprehensive tests to verify all functionality works together",
      "depends_on": [
        "phase-4-storage-management"
      ],
      "parallel_safe": false,
      "subtasks": [
        {
          "id": "subtask-5-1",
          "description": "Create unit tests for buffer operations",
          "service": "backend",
          "files_to_modify": [],
          "files_to_create": [
            "tests/test_screenshot_manager.py"
          ],
          "patterns_from": [
            "tests/__init__.py"
          ],
          "verification": {
            "type": "command",
            "command": "python -m pytest tests/test_screenshot_manager.py::test_buffer_operations -v",
            "expected": "PASSED"
          },
          "status": "pending",
          "notes": "Test add_frame(), get_buffer_size(), buffer wrap-around (maxlen behavior), and _get_frame_before() with various timestamps."
        },
        {
          "id": "subtask-5-2",
          "description": "Create integration test for full capture sequence",
          "service": "backend",
          "files_to_modify": [
            "tests/test_screenshot_manager.py"
          ],
          "files_to_create": [],
          "patterns_from": [],
          "verification": {
            "type": "command",
            "command": "python -m pytest tests/test_screenshot_manager.py::test_capture_sequence -v",
            "expected": "PASSED"
          },
          "status": "pending",
          "notes": "Test async capture_sequence() with real frames. Verify before/current/after are captured correctly. Test JPEG quality and base64 encoding. Verify timestamps are correct."
        },
        {
          "id": "subtask-5-3",
          "description": "Create memory leak test for continuous buffering",
          "service": "backend",
          "files_to_modify": [
            "tests/test_screenshot_manager.py"
          ],
          "files_to_create": [],
          "patterns_from": [],
          "verification": {
            "type": "command",
            "command": "python -m pytest tests/test_screenshot_manager.py::test_memory_stability -v",
            "expected": "PASSED"
          },
          "status": "pending",
          "notes": "Run continuous add_frame() for several seconds. Monitor buffer size stays within maxlen. Verify cleanup_old() prevents unbounded growth. Test with pytest-timeout."
        }
      ]
    }
  ],
  "summary": {
    "total_phases": 5,
    "total_subtasks": 11,
    "services_involved": [
      "backend"
    ],
    "parallelism": {
      "max_parallel_phases": 1,
      "parallel_groups": [],
      "recommended_workers": 1,
      "speedup_estimate": "Sequential - phases have dependencies",
      "reasoning": "Each phase builds on the previous one. Phase 2 needs data structures from Phase 1, Phase 3 needs buffer operations from Phase 2, etc."
    },
    "startup_command": "python -m pytest tests/ -v"
  },
  "verification_strategy": {
    "risk_level": "medium",
    "skip_validation": false,
    "test_creation_phase": "post_implementation",
    "test_types_required": [
      "unit",
      "integration"
    ],
    "security_scanning_required": false,
    "staging_deployment_required": false,
    "acceptance_criteria": [
      "Ring buffer correctly stores and retrieves frames with timestamps",
      "capture_sequence() returns valid before/current/after screenshots",
      "JPEG encoding produces valid images with specified quality",
      "Base64 encoding is compatible with LLM APIs",
      "No memory leaks during continuous operation",
      "cleanup_old() prevents unbounded memory growth",
      "All unit and integration tests pass"
    ],
    "verification_steps": [
      {
        "name": "Unit Tests",
        "command": "python -m pytest tests/test_screenshot_manager.py -v",
        "expected_outcome": "All tests pass",
        "type": "test",
        "required": true,
        "blocking": true
      },
      {
        "name": "Memory Leak Test",
        "command": "python -m pytest tests/test_screenshot_manager.py::test_memory_stability -v --timeout=60",
        "expected_outcome": "No memory growth beyond buffer limit",
        "type": "test",
        "required": true,
        "blocking": true
      },
      {
        "name": "Manual Integration Check",
        "command": "python -c \"import asyncio; from src.screenshot_manager import ScreenshotManager; from src.config import ScreenshotConfig; print('Screenshot system ready')\"",
        "expected_outcome": "No import errors",
        "type": "manual",
        "required": true,
        "blocking": false
      }
    ],
    "reasoning": "Medium risk - new module with memory management concerns. Requires thorough testing for buffer operations and memory leaks. No security concerns (no external input). Integration with motion detector will be tested in later tasks."
  },
  "qa_acceptance": {
    "unit_tests": {
      "required": true,
      "commands": [
        "python -m pytest tests/test_screenshot_manager.py -v"
      ],
      "minimum_coverage": null
    },
    "integration_tests": {
      "required": true,
      "commands": [
        "python -m pytest tests/test_screenshot_manager.py::test_capture_sequence -v"
      ],
      "services_to_test": [
        "backend"
      ]
    },
    "e2e_tests": {
      "required": false,
      "commands": [],
      "flows": []
    },
    "browser_verification": {
      "required": false,
      "pages": []
    },
    "database_verification": {
      "required": false,
      "checks": []
    },
    "custom_checks": [
      {
        "name": "Memory Leak Test",
        "description": "Verify no memory growth during continuous buffering",
        "command": "python -m pytest tests/test_screenshot_manager.py::test_memory_stability -v --timeout=60",
        "required": true
      },
      {
        "name": "Buffer Wrap-around Test",
        "description": "Verify ring buffer correctly discards old frames when full",
        "command": "python -m pytest tests/test_screenshot_manager.py::test_buffer_operations -v",
        "required": true
      }
    ]
  },
  "qa_signoff": null,
  "status": "in_progress",
  "planStatus": "in_progress",
  "updated_at": "2026-01-16T06:45:26.819Z",
  "last_updated": "2026-01-16T06:45:09.178141+00:00"
}